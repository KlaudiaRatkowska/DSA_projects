#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <math.h>
#include <string.h>

#define COMMAND_SIZE 500
#define EMPTY_FIELD 0
#define PLAYER_1 1
#define PLAYER_2 2
#define REMIS 3


struct Game {
        int** board;
        int n;
        int m;
        int k;
        int activePlayer;
        int fieldsLeft;
};

struct Move
{
        int row, col;
};

void makeTable(Game* game) {
        scanf("%d %d %d %d", &game->n, &game->m, &game->k, &game->activePlayer);
        game->fieldsLeft = game->n * game->m;

        game->board = new int*[game->n]; //tworzymy tablice dwuwymiarowa
        for (int i = 0; i < game->n; ++i)
                game->board[i] = new int[game->m];

        for (int i = 0; i < game->n; i++) {
                for (int j = 0; j < game->m; j++) {
                        scanf("%d", &game->board[i][j]);
                        if (game->board[i][j] != EMPTY_FIELD)
                                game->fieldsLeft--;


                }


        }

}

void printBoard(Game* game) {
        for (int i = 0; i < game->n; i++) {
                for (int j = 0; j < game->m; j++) {
                        printf("%d ", game->board[i][j]);


                }
                printf("\n");


        }
}

int horizontal(Game* game) {
        for (int i = 0; i < game->n; i++) {
                int k1 = 0;
                int k2 = 0;
                for (int j = 0; j < game->m; j++) {
                        if (game->board[i][j] == PLAYER_1) {
                                k1++;
                                k2 = 0;


                        }
                        else if (game->board[i][j] == PLAYER_2) {
                                k2++;
                                k1 = 0;


                        }
                        else {
                                k1 = 0;
                                k2 = 0;


                        }
                        if (k1 == game->k) return PLAYER_1;
                        if (k2 == game->k) return PLAYER_2;


                }


        }
        return 0;
}

int vertical(Game* game) {
        for (int j = 0; j < game->m; j++) {
                int k1 = 0;
                int k2 = 0;
                for (int i = 0; i < game->n; i++) {
                        if (game->board[i][j] == PLAYER_1) {
                                k1++;
                                k2 = 0;


                        }
                        else if (game->board[i][j] == PLAYER_2) {
                                k2++;
                                k1 = 0;


                        }
                        else {
                                k1 = 0;
                                k2 = 0;


                        }
                        if (k1 == game->k) return PLAYER_1;
                        if (k2 == game->k) return PLAYER_2;


                }


        }
        return 0;
}
int checkLeftSkos(Game * game, int a, int b) {

        int k1 = 0;
        int k2 = 0;
        int len = fmin(game->m, game->n);
        for (int l = 0; l < len; l++) {
                if (game->board[a][b] == PLAYER_1) {
                        k1++;
                        k2 = 0;


                }
                else if (game->board[a][b] == PLAYER_2) {
                        k2++;
                        k1 = 0;


                }
                else {
                        k1 = 0;
                        k2 = 0;


                }
                if (k1 == game->k) return PLAYER_1;
                if (k2 == game->k) return PLAYER_2;
                a++;
                b--;
                if (b < 0 || a >= game->n)return 0;

        }
        return 0;
}
int leftSlant(Game* game) {
        int len = fmin(game->m, game->n);

        int k1 = 0;
        int k2 = 0;

        for (int i = 0; i < game->n ; i++) {
                int out = checkLeftSkos(game, i, game->m - 1);
                if (out != 0)return out;


        }
        for (int i = 0; i < game->m; i++) {
                int out = checkLeftSkos(game, 0, i);
                if (out != 0)return out;
        }


        return 0;
}

int checkRightSkos(Game * game, int a, int b) {

        int k1 = 0;
        int k2 = 0;
        int len = fmin(game->m, game->n);
        for (int l = 0; l < len; l++) {
                if (game->board[a][b] == PLAYER_1) {
                        k1++;
                        k2 = 0;


                }
                else if (game->board[a][b] == PLAYER_2) {
                        k2++;
                        k1 = 0;


                }
                else {
                        k1 = 0;
                        k2 = 0;


                }
                if (k1 == game->k) return PLAYER_1;
                if (k2 == game->k) return PLAYER_2;
                a++;
                b++;
                if (a >= game->n || b >= game->m)return 0;

        }
        return 0;
}
int rightSlant(Game* game) {
        int a = 0;
        int b = 0;
        int len = fmin(game->m, game->n);

                int k1 = 0;
                int k2 = 0;
                
                for (int i = 0; i < game->m; i++) {
                        int out = checkRightSkos(game, 0, i);
                        if (out != 0)return out;


                }
                for (int i = 0; i < game->n ; i++) {
                        int out = checkRightSkos(game, i, 0);
                        if (out != 0)return out;
                }


        return 0;
}


int isGameOver(Game* game) {
        int ifHorizontal, ifVertical, ifLeftSlant, ifRightSlant;
        ifHorizontal = horizontal(game);
        ifVertical = vertical(game);
        ifLeftSlant = leftSlant(game);
        ifRightSlant = rightSlant(game);

        if (ifHorizontal) return ifHorizontal;
        if (ifVertical) return ifVertical;
        if (ifLeftSlant) return ifLeftSlant;
        if (ifRightSlant) return ifRightSlant;
        if (game->fieldsLeft == 0) return REMIS;

        return 0;
}

void genAllPosMov(Game* game) {
        if (game->fieldsLeft == 0) {
                printf("0\n");


        }
        else {
                if (ceil((game->n * game->m - game->fieldsLeft) / 2.0) < game->k) {
                        printf("%d", game->fieldsLeft);
                        printf("\n");
                        for (int i = 0; i < game->n; i++) {
                                for (int j = 0; j < game->m; j++) {
                                        if (game->board[i][j] == EMPTY_FIELD) {
                                                game->board[i][j] = game->activePlayer;
                                                printBoard(game);
                                                game->board[i][j] = EMPTY_FIELD;


                                        }


                                }


                        }
                        return;


                }
                if (!isGameOver(game)) {
                        printf("%d", game->fieldsLeft);
                        printf("\n");
                        for (int i = 0; i < game->n; i++) {
                                for (int j = 0; j < game->m; j++) {
                                        if (game->board[i][j] == EMPTY_FIELD) {
                                                game->board[i][j] = game->activePlayer;
                                                printBoard(game);
                                                game->board[i][j] = EMPTY_FIELD;


                                        }


                                }


                        }


                }
                else printf("0\n");


        }
}

void deleteBoard(Game* game) {
        for (int i = 0; i < game->n; i++) {
                delete[] game->board[i];


        }
        delete[] game->board;
}

void genAllPosMovIfGameOver(Game* game) {
        bool onlyOne = false;
        if (!isGameOver(game)) {
                for (int i = 0; i < game->n; i++) {
                        for (int j = 0; j < game->m; j++) {
                                if (game->board[i][j] == EMPTY_FIELD) {
                                        game->board[i][j] = game->activePlayer;
                                        if (isGameOver(game)) {
                                                printf("1\n");
                                                printBoard(game);
                                                onlyOne = true;
                                                break;


                                        }
                                        else {
                                                game->board[i][j] = EMPTY_FIELD;


                                        }


                                }



                        }
                        if (onlyOne == true) break;


                }
                if (onlyOne == false)  genAllPosMov(game);


        }
        else printf("0\n");
}
int changePlayer(int player) {
        if (player == PLAYER_1)
                return PLAYER_2;
        else
                return PLAYER_1;
}

int minimax(Game* game, int depth, bool isMax, int player)
{
        //printBoard(game);
        //printf("\n");
        //int score = evaluate(game); //score = 1 pl1 score = 2 pl2
        int score = isGameOver(game);
        if (player == PLAYER_1 && score == PLAYER_1)
                score = 10;
        if (player == PLAYER_2 && score == PLAYER_2)
                score = 10;
        if (player == PLAYER_1 && score == PLAYER_2)
                score = -10;
        if (player == PLAYER_2 && score == PLAYER_1)
                score = -10;

        // If Maximizer has won the game return his/her
        // evaluated score
        if (score == 10)
                return score;

        // If Minimizer has won the game return his/her
        // evaluated score
        if (score == -10)
                return score;

        // If there are no more moves and no winner then
        // it is a tie
        if (game->fieldsLeft == 0)
                return 0;

        // If this maximizer's move
        if (isMax)
        {
                int best = -1000;

                // Traverse all cells
                for (int i = 0; i < game->n; i++)
                {
                        for (int j = 0; j < game->m; j++)
                        {
                                // Check if cell is empty
                                if (game->board[i][j] == EMPTY_FIELD)
                                {
                                        // Make the move
                                        game->board[i][j] = player;
                                        game->fieldsLeft--;
                                        // Call minimax recursively and choose
                                        // the maximum value
                                        int resultMax = minimax(game, depth + 1, !isMax, player);
                                        if (resultMax > best)
                                                best = resultMax;
                                        
                                        //    best = max(best,
                                                        //    minimax(board, depth + 1, !isMax));

                                                        // Undo the move
                                        game->board[i][j] = EMPTY_FIELD;
                                        game->fieldsLeft++;
                                        if (resultMax == 10)return best;
                                }


                        }


                }
                return best;


        }

        // If this minimizer's move
        else
        {
                int best = 1000;

                // Traverse all cells
                for (int i = 0; i < game->n; i++)
                {
                        for (int j = 0; j < game->m; j++)
                        {
                                // Check if cell is empty
                                if (game->board[i][j] == EMPTY_FIELD)
                                {
                                        // Make the move
                                        int opponent = changePlayer(player);
                                        game->board[i][j] = opponent;
                                        game->fieldsLeft--;
                                        // Call minimax recursively and choose
                                        // the minimum value
                                        int resultMin = minimax(game, depth + 1, !isMax, player);
                                        if (resultMin < best)
                                                best = resultMin;
                                        //   best = min(best,
                                          //     minimax(board, depth + 1, !isMax));

                                           // Undo the move
                                        game->board[i][j] = EMPTY_FIELD;
                                        game->fieldsLeft++;
                                        if (resultMin == -10)return best;
                                }


                        }


                }
                return best;


        }
}

void solveGameState(Game* game) {
        bool endGame = false;
        int player = game->activePlayer;
        Move bestMove;


        int result = isGameOver(game);
        if (result)
        {
                if (result == PLAYER_1)
                        printf("FIRST_PLAYER_WINS\n");
                if (result == PLAYER_2)
                        printf("SECOND_PLAYER_WINS\n");
                if (result == REMIS)
                        printf("BOTH_PLAYERS_TIE\n");
                return;

        }
        else
        {
                int bestVal = -1000;
                bestMove.row = -1;
                bestMove.col = -1;
                for (int i = 0; i < game->n; i++)
                {
                        for (int j = 0; j < game->m; j++)
                        {
                                // Check if cell is empty
                                if (game->board[i][j] == EMPTY_FIELD)
                                {
                                        // Make the move
                                        game->board[i][j] = player;
                                        game->fieldsLeft--;
                                        int win = isGameOver(game);
                                        if (win) {
                                                if (win == PLAYER_1)
                                                        printf("FIRST_PLAYER_WINS\n");
                                                if (win == PLAYER_2)
                                                        printf("SECOND_PLAYER_WINS\n");
                                                if (win == REMIS)
                                                        printf("BOTH_PLAYERS_TIE\n");

                                                endGame = true;
                                                return;


                                        }
                                        // compute evaluation function for this
                                        // move.

                                        int moveVal = minimax(game, 0, false, player);

                                        // Undo the move
                                        game->board[i][j] = EMPTY_FIELD;
                                        game->fieldsLeft++;
                                        // If the value of the current move is
                                        // more than the best value, then update
                                        // best/
                                        //printf("%d\n", moveVal);
                                        if (moveVal > bestVal)
                                        {
                                                bestMove.row = i;
                                                bestMove.col = j;
                                                bestVal = moveVal;


                                        }


                                }


                        }
                        if (endGame == true)
                                break;


                }
                if (bestVal == 10 && game->activePlayer == PLAYER_1 || bestVal == -10 && game->activePlayer == PLAYER_2)
                        printf("FIRST_PLAYER_WINS\n");
                else if (bestVal == 10 && game->activePlayer == PLAYER_2 || bestVal == -10 && game->activePlayer == PLAYER_1)
                        printf("SECOND_PLAYER_WINS\n");
                else
                        printf("BOTH_PLAYERS_TIE\n");

        }

}


int main()
{
        Game game;
        char command[COMMAND_SIZE];
        while (true) {
                scanf("%s", command);
                if (feof(stdin) != 0) {
                        break;


                }
                else if (!strcmp(command, "GEN_ALL_POS_MOV")) {
                        makeTable(&game);
                        genAllPosMov(&game);
                        deleteBoard(&game);


                }
                else if (!strcmp(command, "GEN_ALL_POS_MOV_CUT_IF_GAME_OVER")) {
                        makeTable(&game);
                        genAllPosMovIfGameOver(&game);
                        deleteBoard(&game);


                }
                else if (!strcmp(command, "SOLVE_GAME_STATE")) {
                        makeTable(&game);
                        solveGameState(&game);
                        deleteBoard(&game);


                }


        }
        return 0;
}
